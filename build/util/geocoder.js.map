{"version":3,"sources":["geocoder.js"],"names":["Geocoder","geocoderApi","geocoderConfig","api","query","autocomplete","getAutocompleteQuery","then","rewriteAutocompleteResponse","feature","location","lonlat","fromCoordinates","geometry","coordinates","name","properties","label","Promise","resolve","reverse","getReverseQuery","rewriteReverseResponse","search","getSearchQuery","rewriteSearchResponse","apiKey","baseUrl","boundary","options","focusPoint","url","undefined","format","response","ArcGISGeocoder","magicKey","text","features","filter","isCollection","map","lat","lon","NoApiGeocoder","parseCoordinateString","point","roundGPSDecimal","string","toCoordinates","fromLatFirstString","type","e","number","roundFactor","Math","round","PeliasGeocoder","sources","isomorphicMapzenSearchQuery","address","getGeocoder","arcgis","pelias","console","error"],"mappings":"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","sourcesContent":["import * as arcgis from '@conveyal/geocoder-arcgis-geojson'\nimport lonlat from '@conveyal/lonlat'\nimport * as pelias from 'isomorphic-mapzen-search'\nimport memoize from 'lodash.memoize'\n\n/**\n * Create customized geocoder functions given a certain geocoding API, the\n * config for the geocoder and response rewrite functions specific to this\n * application. Any geocoder api that is added is expected to have an API that\n * behaves very closely to https://github.com/conveyal/isomorphic-mapzen-search\n */\nclass Geocoder {\n  constructor (geocoderApi, geocoderConfig) {\n    this.api = geocoderApi\n    this.geocoderConfig = geocoderConfig\n  }\n\n  /**\n   * Perform an autocomplete query. Eg, using partial text of a possible\n   * address or POI, attempt to find possible matches.\n   */\n  autocomplete (query) {\n    return this.api.autocomplete(this.getAutocompleteQuery(query))\n      .then(this.rewriteAutocompleteResponse)\n  }\n\n  /**\n   * Get an application-specific data structure from a given feature. The\n   * feature is either the result of an autocomplete or a search query. This\n   * function returns a Promise because sometimes an asynchronous action\n   * needs to be taken to translate a feature into a location. For example,\n   * the ArcGIS autocomplete service returns results that lack full address\n   * data and GPS and it is expected that an extra call to the `search` API is\n   * done to obtain that detailed data.\n   */\n  getLocationFromGeocodedFeature (feature) {\n    const location = lonlat.fromCoordinates(feature.geometry.coordinates)\n    location.name = feature.properties.label\n    return Promise.resolve(location)\n  }\n\n  /**\n   * Do a reverse-geocode. ie get address information and attributes given a\n   * GPS coordiante.\n   */\n  reverse (query) {\n    return this.api.reverse(this.getReverseQuery(query))\n      .then(this.rewriteReverseResponse)\n  }\n\n  /**\n   * Perform a search query. A search query is different from autocomplete in\n   * that it is assumed that the text provided is more or less a complete\n   * well-fromatted address.\n   */\n  search (query) {\n    return this.api.search(this.getSearchQuery(query))\n      .then(this.rewriteSearchResponse)\n  }\n\n  /**\n   * Default autocomplete query generator\n   */\n  getAutocompleteQuery (query) {\n    const {apiKey, baseUrl, boundary, options, focusPoint} = this.geocoderConfig\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      options,\n      url: baseUrl ? `${baseUrl}/autocomplete` : undefined,\n      ...query\n    }\n  }\n\n  /**\n   * Default reverse query generator\n   */\n  getReverseQuery (query) {\n    const {apiKey, baseUrl, options} = this.geocoderConfig\n    return {\n      apiKey,\n      format: true,\n      options,\n      url: baseUrl ? `${baseUrl}/reverse` : undefined,\n      ...query\n    }\n  }\n\n  /**\n   * Default search query generator.\n   */\n  getSearchQuery (query) {\n    const {apiKey, baseUrl, boundary, focusPoint, options} = this.geocoderConfig\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      options,\n      url: baseUrl ? `${baseUrl}/search` : undefined,\n      format: false, // keep as returned GeoJSON,\n      ...query\n    }\n  }\n\n  /**\n   * Default rewriter for autocomplete responses\n   */\n  rewriteAutocompleteResponse (response) { return response }\n\n  /**\n   * Default rewriter for reverse responses\n   */\n  rewriteReverseResponse (response) { return response }\n\n  /**\n   * Default rewriter for search responses\n   */\n  rewriteSearchResponse (response) { return response }\n}\n\n/**\n * Geocoder implementation for the ArcGIS geocoder.\n * See https://developers.arcgis.com/rest/geocode/api-reference/overview-world-geocoding-service.htm\n *\n * @extends Geocoder\n */\nclass ArcGISGeocoder extends Geocoder {\n  /**\n   * Using the given magicKey and text, perform a search query to get detailed\n   * address and GPS data. Return data in an application-specific location\n   * format.\n   */\n  getLocationFromGeocodedFeature (feature) {\n    return this.api.search({ magicKey: feature.magicKey, text: feature.text })\n      .then(response => {\n        const feature = response.features[0]\n        const location = lonlat.fromCoordinates(feature.geometry.coordinates)\n        location.name = feature.properties.label\n        return location\n      })\n  }\n\n  /**\n   * Rewrite an autocomplete response into an application specific data format.\n   * Also, filter out any results that are collections.\n   */\n  rewriteAutocompleteResponse (response) {\n    return {\n      // remove any autocomplete results that are collections\n      // (eg multiple Starbucks)\n      features: response.features.filter(feature => !feature.isCollection)\n        // add label property so location-field can handle things ok\n        .map(feature => ({\n          ...feature,\n          properties: {\n            label: feature.text\n          }\n        }))\n    }\n  }\n\n  /**\n   * Rewrite the response into an application-specific data format using the\n   * first feature returned from the geocoder.\n   */\n  rewriteReverseResponse (response) {\n    const { features, query } = response\n    const { lat, lon } = query\n    return {\n      lat,\n      lon,\n      name: features[0].properties.label\n    }\n  }\n}\n\n/**\n * An implementation that doesn't use an API for geocoding. Merely allows\n * clicking on the map and finding GPS coordinates by typing them in.\n *\n * @extends Geocoder\n */\nclass NoApiGeocoder extends Geocoder {\n  /**\n   * Use coordinate string parser.\n   */\n  autocomplete (query) {\n    return this.parseCoordinateString(query.text)\n  }\n\n  /**\n   * Always return the lat/lon.\n   */\n  reverse (query) {\n    let { lat, lon } = query.point\n    lat = this.roundGPSDecimal(lat)\n    lon = this.roundGPSDecimal(lon)\n    return Promise.resolve({ lat, lon, name: `${lat}, ${lon}` })\n  }\n\n  /**\n   * Use coordinate string parser.\n   */\n  search (query) {\n    return this.parseCoordinateString(query.text)\n  }\n\n  /**\n   * Attempt to parse the input as a GPS coordinate. If parseable, return a\n   * feature.\n   */\n  parseCoordinateString (string) {\n    let feature\n    try {\n      feature = {\n        geometry: {\n          coordinates: lonlat.toCoordinates(lonlat.fromLatFirstString(string)),\n          type: 'Point'\n        },\n        properties: {\n          label: string\n        }\n      }\n    } catch (e) {\n      return Promise.resolve({ features: [] })\n    }\n    return Promise.resolve({ features: [feature] })\n  }\n\n  roundGPSDecimal (number) {\n    const roundFactor = 100000\n    return Math.round(number * roundFactor) / roundFactor\n  }\n}\n\n/**\n * Geocoder implementation for the Pelias geocoder.\n * See https://pelias.io\n *\n * This is exported for testing purposes only.\n *\n * @extends Geocoder\n */\nexport class PeliasGeocoder extends Geocoder {\n  /**\n   * Generate an autocomplete query specifically for the Pelias API. The\n   * `sources` parameter is a Pelias-specific option.\n   */\n  getAutocompleteQuery (query) {\n    const {apiKey, baseUrl, boundary, focusPoint, options, sources} = this.geocoderConfig\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      options,\n      // explicitly send over null for sources if provided sources is not truthy\n      // in order to avoid default isomorphic-mapzen-search sources form being\n      // applied\n      sources: sources || null,\n      url: baseUrl ? `${baseUrl}/autocomplete` : undefined,\n      ...query\n    }\n  }\n\n  /**\n   * Generate a search query specifically for the Pelias API. The\n   * `sources` parameter is a Pelias-specific option.\n   */\n  getSearchQuery (query) {\n    const {apiKey, baseUrl, boundary, focusPoint, options, sources} = this.geocoderConfig\n    return {\n      apiKey,\n      boundary,\n      focusPoint,\n      // explicitly send over null for sources if provided sources is not truthy\n      // in order to avoid default isomorphic-mapzen-search sources form being\n      // applied\n      options,\n      sources: sources || null,\n      url: baseUrl ? `${baseUrl}/search` : undefined,\n      format: false, // keep as returned GeoJSON,\n      ...query\n    }\n  }\n\n  /**\n   * Rewrite the response into an application-specific data format using the\n   * first feature returned from the geocoder.\n   */\n  rewriteReverseResponse (response) {\n    const { 'point.lat': lat, 'point.lon': lon } = response.isomorphicMapzenSearchQuery\n    return {\n      lat,\n      lon,\n      name: response[0].address\n    }\n  }\n}\n\n// Create a memoized getter to avoid recreating new geocoders each time.\nconst getGeocoder = memoize(geocoderConfig => {\n  if (!geocoderConfig || !geocoderConfig.type) {\n    return new NoApiGeocoder()\n  }\n  const {type} = geocoderConfig\n  switch (type) {\n    case 'ARCGIS':\n      return new ArcGISGeocoder(arcgis, geocoderConfig)\n    case 'PELIAS':\n      return new PeliasGeocoder(pelias, geocoderConfig)\n    default:\n      console.error(`Unkown geocoder type: \"${type}\". Using NoApiGeocoder.`)\n      return new NoApiGeocoder()\n  }\n})\n\nexport default getGeocoder\n"]}