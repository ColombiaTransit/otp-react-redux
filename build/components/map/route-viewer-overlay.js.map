{"version":3,"sources":["route-viewer-overlay.js"],"names":["geomToArray","point","lat","lon","RouteViewerOverlay","nextProps","console","log","routeData","patterns","length","allPoints","reduce","acc","ptn","concat","geometry","map","context","fitBounds","props","routeColor","color","segments","forEach","pattern","pts","push","patternId","MapLayer","propTypes","mapStateToProps","state","ownProps","viewedRoute","otp","ui","transitIndex","routes","routeId","mapDispatchToProps"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;AACA;;AAEA;;;;;;AAEA,SAASA,WAAT,CAAsBC,KAAtB,EAA6B;AAC3B,SAAO,CAACA,MAAMC,GAAP,EAAYD,MAAME,GAAlB,CAAP;AACD;;IAEKC,kB;;;;;;;;;;wCAGiB,CAAE;;AAEvB;;;;2CACwB,CAAE;;;8CAECC,S,EAAW;AACpCC,cAAQC,GAAR,CAAYF,SAAZ;AACA;AACA,UAAIA,UAAUG,SAAV,IAAuBH,UAAUG,SAAV,CAAoBC,QAA3C,IAAuD,oBAAYJ,UAAUG,SAAV,CAAoBC,QAAhC,EAA0CC,MAA1C,GAAmD,CAA9G,EAAiH;AAC/G,YAAMC,YAAY,sBAAcN,UAAUG,SAAV,CAAoBC,QAAlC,EAA4CG,MAA5C,CAChB,UAACC,GAAD,EAAMC,GAAN;AAAA,iBAAcD,IAAIE,MAAJ,CAAWD,IAAIE,QAAJ,CAAaC,GAAb,CAAiBjB,WAAjB,CAAX,CAAd;AAAA,SADgB,EAEhB,EAFgB,CAAlB;AAIA,aAAKkB,OAAL,CAAaD,GAAb,CAAiBE,SAAjB,CAA2BR,SAA3B;AACD;AACF;;;2CAEuB,CAAE;;;2CAEF,CAAE;;;6BAEhB;AAAA,UACAH,SADA,GACc,KAAKY,KADnB,CACAZ,SADA;;;AAGR,UAAI,CAACA,SAAD,IAAc,CAACA,UAAUC,QAA7B,EAAuC,OAAO,8BAAC,0BAAD,OAAP;;AAEvC,UAAMY,aAAab,UAAUc,KAAV,SAAsBd,UAAUc,KAAhC,GAA0C,SAA7D;AACA,UAAMC,WAAW,EAAjB;AACA,4BAAcf,UAAUC,QAAxB,EAAkCe,OAAlC,CAA0C,mBAAW;AACnD,YAAI,CAACC,QAAQT,QAAb,EAAuB;AACvB,YAAMU,MAAMD,QAAQT,QAAR,CAAiBC,GAAjB,CAAqBjB,WAArB,CAAZ;AACAuB,iBAASI,IAAT,CACE,8BAAC,sBAAD;AACE,qBAAWD,GADb;AAEE,kBAAQ,CAFV;AAGE,iBAAOL,UAHT;AAIE,mBAAS,CAJX;AAKE,eAAKI,QAAQG;AALf,UADF;AASD,OAZD;;AAcA,aAAOL,SAASb,MAAT,GAAkB,CAAlB,GACH;AAAC,kCAAD;AAAA;AAAc;AAAA;AAAA;AAAMa;AAAN;AAAd,OADG,GAEH,8BAAC,0BAAD,OAFJ;AAGD;;;EAhD8BM,sB,UACxBC,S,GAAY,E;;AAkDrB;;AAEA,IAAMC,kBAAkB,SAAlBA,eAAkB,CAACC,KAAD,EAAQC,QAAR,EAAqB;AAC3C,MAAMC,cAAcF,MAAMG,GAAN,CAAUC,EAAV,CAAaF,WAAjC;AACA,SAAO;AACLA,4BADK;AAEL1B,eAAW0B,eAAeF,MAAMG,GAAN,CAAUE,YAAV,CAAuBC,MAAtC,GACPN,MAAMG,GAAN,CAAUE,YAAV,CAAuBC,MAAvB,CAA8BJ,YAAYK,OAA1C,CADO,GAEP;AAJC,GAAP;AAMD,CARD;;AAUA,IAAMC,qBAAqB,EAA3B;;kBAEe,yBAAQT,eAAR,EAAyBS,kBAAzB,EAA6CpC,kBAA7C,C","file":"route-viewer-overlay.js","sourcesContent":["import React from 'react'\nimport { connect } from 'react-redux'\nimport { FeatureGroup, MapLayer, Polyline } from 'react-leaflet'\n\nimport polyline from '@mapbox/polyline'\n\nfunction geomToArray (point) {\n  return [point.lat, point.lon]\n}\n\nclass RouteViewerOverlay extends MapLayer {\n  static propTypes = {}\n\n  componentDidMount () {}\n\n  // TODO: determine why the default MapLayer componentWillUnmount() method throws an error\n  componentWillUnmount () {}\n\n  componentWillReceiveProps (nextProps) {\n    console.log(nextProps);\n    // if pattern geometry just finished populating, update the map points\n    if (nextProps.routeData && nextProps.routeData.patterns && Object.keys(nextProps.routeData.patterns).length > 0) {\n      const allPoints = Object.values(nextProps.routeData.patterns).reduce(\n        (acc, ptn) => acc.concat(ptn.geometry.map(geomToArray)),\n        []\n      )\n      this.context.map.fitBounds(allPoints)\n    }\n  }\n\n  createLeafletElement () {}\n\n  updateLeafletElement () {}\n\n  render () {\n    const { routeData } = this.props\n\n    if (!routeData || !routeData.patterns) return <FeatureGroup />\n\n    const routeColor = routeData.color ? `#${routeData.color}` : '#00bfff'\n    const segments = []\n    Object.values(routeData.patterns).forEach(pattern => {\n      if (!pattern.geometry) return\n      const pts = pattern.geometry.map(geomToArray)\n      segments.push(\n        <Polyline\n          positions={pts}\n          weight={4}\n          color={routeColor}\n          opacity={1}\n          key={pattern.patternId}\n        />\n      )\n    })\n\n    return segments.length > 0\n      ? <FeatureGroup><div>{segments}</div></FeatureGroup>\n      : <FeatureGroup />\n  }\n}\n\n// connect to the redux store\n\nconst mapStateToProps = (state, ownProps) => {\n  const viewedRoute = state.otp.ui.viewedRoute\n  return {\n    viewedRoute,\n    routeData: viewedRoute && state.otp.transitIndex.routes\n      ? state.otp.transitIndex.routes[viewedRoute.routeId]\n      : null\n  }\n}\n\nconst mapDispatchToProps = {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(RouteViewerOverlay)\n"]}