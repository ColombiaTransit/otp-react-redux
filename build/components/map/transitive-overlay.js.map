{"version":3,"sources":["transitive-overlay.js"],"names":["require","checkHiPPI","canvas","window","devicePixelRatio","PIXEL_RATIO","style","width","height","context","getContext","scale","zoomFactors","minScale","gridCellSize","internalVertexFactor","angleConstraint","mergeVertexThreshold","useGeographicRendering","TransitiveCanvasOverlay","map","L","canvasLayer","delegate","addTo","nextProps","_transitive","transitiveData","props","updateData","render","_updateBoundsAndRender","routingType","activeItinerary","focusJourney","journeys","journey_id","mapBounds","getBounds","Transitive","data","initialBounds","getWest","getSouth","getEast","getNorth","zoomEnabled","autoResize","styles","display","console","log","setDisplayBounds","info","_initTransitive","mapSize","getSize","_lastMapSize","x","y","setDimensions","setCanvas","coords","fromProps","toProps","MapLayer","propTypes","PropTypes","object","mapStateToProps","state","ownProps","activeSearch","otp","query","response","plan","itins","mapDispatchToProps"],"mappings":"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","file":"transitive-overlay.js","sourcesContent":["import { PropTypes } from 'react'\nimport { MapLayer } from 'react-leaflet'\nimport L from 'leaflet'\nimport { connect } from 'react-redux'\nimport Transitive from 'transitive-js'\nimport isEqual from 'lodash.isequal'\n\nrequire('./leaflet-canvas-layer')\n\nimport { getActiveSearch, getActiveItineraries } from '../../util/state'\nimport { itineraryToTransitive } from '../../util/map'\n\n// TODO: move to util?\nfunction checkHiPPI (canvas) {\n  if (window.devicePixelRatio > 1) {\n    const PIXEL_RATIO = 2\n    canvas.style.width = canvas.width + 'px'\n    canvas.style.height = canvas.height + 'px'\n\n    canvas.width *= PIXEL_RATIO\n    canvas.height *= PIXEL_RATIO\n\n    var context = canvas.getContext('2d')\n    context.scale(PIXEL_RATIO, PIXEL_RATIO)\n  }\n}\n\nconst zoomFactors = [{\n  minScale: 0,\n  gridCellSize: 0,\n  internalVertexFactor: 0,\n  angleConstraint: 5,\n  mergeVertexThreshold: 0,\n  useGeographicRendering: true\n}]\n\nclass TransitiveCanvasOverlay extends MapLayer {\n  static propTypes = {\n    transitiveData: PropTypes.object\n  }\n\n  // React Lifecycle Methods\n\n  componentDidMount () {\n    const map = this.context.map\n\n    L.canvasLayer()\n      .delegate(this) // -- if we do not inherit from L.CanvasLayer  we can setup a delegate to receive events from L.CanvasLayer\n      .addTo(map)\n  }\n\n  componentWillReceiveProps (nextProps) {\n    // Check if we received new transitive data\n    if (this._transitive && !isEqual(nextProps.transitiveData, this.props.transitiveData)) {\n      this._transitive.updateData(nextProps.transitiveData)\n      if (!nextProps.transitiveData) this._transitive.render()\n      else this._updateBoundsAndRender()\n    }\n\n    if ( // this block only applies for profile trips where active option changed\n      nextProps.routingType === 'PROFILE' &&\n      nextProps.activeItinerary !== this.props.activeItinerary\n    ) {\n      if (nextProps.activeItinerary == null) { // no option selected; clear focus\n        this._transitive.focusJourney(null)\n        this._transitive.render()\n      } else if (nextProps.transitiveData) {\n        this._transitive.focusJourney(nextProps.transitiveData.journeys[nextProps.activeItinerary].journey_id)\n        this._transitive.render()\n      }\n    }\n  }\n\n  componentWillUnmount () {\n    if (this._transitive) {\n      this._transitive.updateData(null)\n      this._transitive.render()\n    }\n  }\n\n  // Internal Methods\n\n  _initTransitive (canvas) {\n    const map = this.context.map\n\n    // set up the transitive instance\n    const mapBounds = map.getBounds()\n    this._transitive = new Transitive({\n      data: this.props.transitiveData,\n      initialBounds: [[mapBounds.getWest(), mapBounds.getSouth()], [mapBounds.getEast(), mapBounds.getNorth()]],\n      zoomEnabled: false,\n      autoResize: false,\n      styles: require('./transitive-styles'),\n      zoomFactors,\n      display: 'canvas',\n      canvas\n    })\n\n    checkHiPPI(canvas)\n\n    // the initial map draw\n    this._updateBoundsAndRender()\n  }\n\n  _updateBoundsAndRender () {\n    if (!this._transitive) {\n      console.log('WARNING: Transitive object not set in transitive-canvas-overlay')\n      return\n    }\n\n    const mapBounds = this.context.map.getBounds()\n    this._transitive.setDisplayBounds([[mapBounds.getWest(), mapBounds.getSouth()], [mapBounds.getEast(), mapBounds.getNorth()]])\n    this._transitive.render()\n  }\n\n  // Leaflet Layer API Methods\n\n  onDrawLayer (info) {\n    if (!this._transitive) this._initTransitive(info.canvas)\n\n    const mapSize = this.context.map.getSize()\n    if (this._lastMapSize && (\n        mapSize.x !== this._lastMapSize.x ||\n        mapSize.y !== this._lastMapSize.y\n      )\n    ) {\n      const canvas = info.canvas\n      checkHiPPI(canvas)\n      this._transitive.display.setDimensions(mapSize.x, mapSize.y)\n      this._transitive.display.setCanvas(canvas)\n    }\n\n    this._updateBoundsAndRender()\n\n    this._lastMapSize = this.context.map.getSize()\n  }\n\n  createTile (coords) {\n  }\n\n  createLeafletElement (props) {\n  }\n\n  updateLeafletElement (fromProps, toProps) {\n  }\n}\n\n// connect to the redux store\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeSearch = getActiveSearch(state.otp)\n  let transitiveData = null\n  if (activeSearch && activeSearch.query.routingType === 'ITINERARY' && activeSearch.response && activeSearch.response.plan) {\n    const itins = getActiveItineraries(state.otp)\n    // TODO: prevent itineraryToTransitive() from being called more than needed\n    transitiveData = itineraryToTransitive(itins[activeSearch.activeItinerary])\n  } else if (activeSearch && activeSearch.response && activeSearch.response.otp) {\n    transitiveData = activeSearch.response.otp\n  }\n\n  return {\n    transitiveData,\n    activeItinerary: activeSearch && activeSearch.activeItinerary,\n    routingType: activeSearch && activeSearch.query && activeSearch.query.routingType\n  }\n}\n\nconst mapDispatchToProps = {\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TransitiveCanvasOverlay)\n"]}