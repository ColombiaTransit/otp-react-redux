{"version":3,"sources":["responsive-webapp.js"],"names":["isMobile","coreUtils","ui","ResponsiveWebapp","prevProps","props","currentPosition","location","query","title","document","urlParams","getUrlParams","newSearchId","ui_activeSearch","replanningTrip","activeSearchId","formChanged","error","coords","pt","lat","latitude","lon","longitude","from","setLocationToCurrent","locationType","setMapCenter","initZoomOnLocate","setMapZoom","zoom","pathname","matchContentToUrl","window","addEventListener","handleBackButtonPress","getCurrentPosition","navigator","geolocation","watchPosition","position","receivedPositionResponse","console","log","enableHighAccuracy","search","parseUrlQueryString","removeEventListener","desktopView","mobileView","Component","PropTypes","element","number","object","mapStateToProps","state","ownProps","activeItinerary","otp","currentQuery","searches","mobileScreen","config","map","modeGroups","mapDispatchToProps","history","WebappWithRouter","RouterWrapper","routerConfig","basename","routerProps","mapStateToWrapperProps","reactRouter"],"mappings":"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","sourcesContent":["import { ConnectedRouter } from 'connected-react-router'\nimport { createHashHistory } from 'history'\nimport isEqual from 'lodash.isequal'\nimport coreUtils from '@opentripplanner/core-utils'\nimport PropTypes from 'prop-types'\nimport React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { Route, Switch, withRouter } from 'react-router'\n\nimport PrintLayout from './print-layout'\nimport { setMapCenter, setMapZoom } from '../../actions/config'\nimport { formChanged, parseUrlQueryString } from '../../actions/form'\nimport { getCurrentPosition, receivedPositionResponse } from '../../actions/location'\nimport { setLocationToCurrent } from '../../actions/map'\nimport { handleBackButtonPress, matchContentToUrl } from '../../actions/ui'\nimport { getActiveItinerary, getTitle } from '../../util/state'\n\nconst { isMobile } = coreUtils.ui\n\nclass ResponsiveWebapp extends Component {\n  static propTypes = {\n    desktopView: PropTypes.element,\n    initZoomOnLocate: PropTypes.number,\n    mobileView: PropTypes.element,\n    query: PropTypes.object\n  }\n\n  /** Lifecycle methods **/\n\n  componentDidUpdate (prevProps) {\n    const { currentPosition, location, query, title } = this.props\n    document.title = title\n    const urlParams = coreUtils.query.getUrlParams()\n    const newSearchId = urlParams.ui_activeSearch\n    // Determine if trip is being replanned by checking the active search ID\n    // against the ID found in the URL params. If they are different, a new one\n    // has been routed to (see handleBackButtonPress) and there is no need to\n    // trigger a form change because necessarily the query will be different\n    // from the previous query.\n    const replanningTrip = newSearchId && this.props.activeSearchId && newSearchId !== this.props.activeSearchId\n    if (!isEqual(prevProps.query, query) && !replanningTrip) {\n      // Trigger on form change action if previous query is different from\n      // current one AND trip is not being replanned already. This will\n      // determine whether a search needs to be made, the mobile view needs\n      // updating, etc.\n      this.props.formChanged(prevProps.query, query)\n    }\n\n    // check if device position changed (typically only set once, on initial page load)\n    if (currentPosition !== prevProps.currentPosition) {\n      if (currentPosition.error || !currentPosition.coords) return\n      const pt = {\n        lat: currentPosition.coords.latitude,\n        lon: currentPosition.coords.longitude\n      }\n\n      // if in mobile mode and from field is not set, use current location as from and recenter map\n      if (isMobile() && this.props.query.from === null) {\n        this.props.setLocationToCurrent({ locationType: 'from' })\n        this.props.setMapCenter(pt)\n        if (this.props.initZoomOnLocate) {\n          this.props.setMapZoom({ zoom: this.props.initZoomOnLocate })\n        }\n      }\n    }\n    // If the path changes (e.g., via a back button press) check whether the\n    // main content needs to switch between, for example, a viewer and a search.\n    if (!isEqual(location.pathname, prevProps.location.pathname)) {\n      // console.log('url changed to', location.pathname)\n      this.props.matchContentToUrl(location)\n    }\n    // Check for change between ITINERARY and PROFILE routingTypes\n    // TODO: restore this for profile mode\n    /* if (query.routingType !== nextProps.query.routingType) {\n      let queryModes = nextProps.query.mode.split(',')\n      // If we are entering 'ITINERARY' mode, ensure that one and only one access mode is selected\n      if (nextProps.query.routingType === 'ITINERARY') {\n        queryModes = ensureSingleAccessMode(queryModes)\n        this.props.setQueryParam({ mode: queryModes.join(',') })\n      }\n      // If we are entering 'PROFILE' mode, ensure that CAR_HAIL is not selected\n      // TODO: make this more generic, i.e. introduce concept of mode->routingType permissions\n      if (nextProps.query.routingType === 'ITINERARY') {\n        queryModes = queryModes.filter(mode => mode !== 'CAR_HAIL')\n        this.props.setQueryParam({ mode: queryModes.join(',') })\n      }\n    } */\n  }\n\n  componentDidMount () {\n    // Add on back button press behavior.\n    window.addEventListener('popstate', this.props.handleBackButtonPress)\n    const { location, title } = this.props\n    document.title = title\n    if (isMobile()) {\n      // If on mobile browser, check position on load\n      this.props.getCurrentPosition()\n\n      // Also, watch for changes in position on mobile\n      navigator.geolocation.watchPosition(\n        // On success\n        position => { this.props.receivedPositionResponse({ position }) },\n        // On error\n        error => { console.log('error in watchPosition', error) },\n        // Options\n        { enableHighAccuracy: true }\n      )\n    }\n\n    if (location && location.search) {\n      // Set search params and plan trip if routing enabled and a query exists\n      // in the URL.\n      this.props.parseUrlQueryString()\n    }\n    // Handle routing to a specific part of the app (e.g. stop viewer) on page\n    // load.\n    this.props.matchContentToUrl(this.props.location)\n  }\n\n  componentWillUnmount () {\n    // Remove on back button press listener.\n    window.removeEventListener('popstate')\n  }\n\n  render () {\n    const { desktopView, mobileView } = this.props\n    return isMobile() ? mobileView : desktopView\n  }\n}\n\n// connect to the redux store\n\nconst mapStateToProps = (state, ownProps) => {\n  const title = getTitle(state)\n  return {\n    activeItinerary: getActiveItinerary(state.otp),\n    activeSearchId: state.otp.activeSearchId,\n    currentPosition: state.otp.location.currentPosition,\n    query: state.otp.currentQuery,\n    searches: state.otp.searches,\n    mobileScreen: state.otp.ui.mobileScreen,\n    initZoomOnLocate: state.otp.config.map && state.otp.config.map.initZoomOnLocate,\n    modeGroups: state.otp.config.modeGroups,\n    title\n  }\n}\n\nconst mapDispatchToProps = {\n  formChanged,\n  getCurrentPosition,\n  handleBackButtonPress,\n  matchContentToUrl,\n  parseUrlQueryString,\n  receivedPositionResponse,\n  setLocationToCurrent,\n  setMapCenter,\n  setMapZoom\n}\n\nconst history = createHashHistory()\n\nconst WebappWithRouter = withRouter(\n  connect(mapStateToProps, mapDispatchToProps)(ResponsiveWebapp)\n)\n\nclass RouterWrapper extends Component {\n  render () {\n    const { routerConfig } = this.props\n    return (\n      <ConnectedRouter\n        basename={routerConfig && routerConfig.basename}\n        history={history}>\n        <div>\n          <Switch>\n            <Route\n              exact\n              path={[\n                // App root\n                '/',\n                // Load app with preset lat/lon/zoom and optional router\n                // NOTE: All params will be cast to :id in matchContentToUrl due\n                // to a quirk with react-router.\n                // https://github.com/ReactTraining/react-router/issues/5870#issuecomment-394194338\n                '/@/:latLonZoomRouter',\n                '/start/:latLonZoomRouter',\n                // Route viewer (and route ID).\n                '/route',\n                '/route/:id',\n                // Stop viewer (and stop ID).\n                '/stop',\n                '/stop/:id'\n              ]}\n              render={() => <WebappWithRouter {...this.props} />}\n            />\n            <Route\n              path='/print'\n              component={(routerProps) => {\n                // combine the router props with the other props that get\n                // passed to the exported component. This way it's possible for\n                // the PrintLayout component to receive the custom icons prop.\n                const props = { ...this.props, ...routerProps }\n                return <PrintLayout {...props} />\n              }}\n            />\n            {/* For any other route, simply return the web app. */}\n            <Route\n              render={() => <WebappWithRouter {...this.props} />}\n            />\n          </Switch>\n        </div>\n      </ConnectedRouter>\n    )\n  }\n}\nconst mapStateToWrapperProps = (state, ownProps) => ({ routerConfig: state.otp.config.reactRouter })\nexport default connect(mapStateToWrapperProps)(RouterWrapper)\n"]}