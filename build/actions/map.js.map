{"version":3,"sources":["map.js"],"names":["clearLocation","setLocation","setLocationToCurrent","switchLocations","clearingLocation","settingLocation","switchingLocations","payload","dispatch","getState","otpState","otp","reverseGeocode","config","geocoder","MAPZEN_KEY","baseUrl","point","location","apiKey","format","url","then","json","name","address","type","catch","err","console","warn","currentPosition","error","coords","lat","latitude","lon","longitude","currentQuery","from","to","showLegDiagram","setElevationPoint"],"mappings":"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","file":"map.js","sourcesContent":["import {reverse} from 'isomorphic-mapzen-search'\nimport { createAction } from 'redux-actions'\n\nimport { formChanged } from './form'\n\n/* SET_LOCATION action creator. Updates a from or to location in the store\n *\n * payload format: {\n *   type: 'from' or 'to'\n *   location: {\n *     name: (string),\n *     lat: (number)\n *     lat: (number)\n *   }\n */\n\nexport const clearingLocation = createAction('CLEAR_LOCATION')\nexport const settingLocation = createAction('SET_LOCATION')\nexport const switchingLocations = createAction('SWITCH_LOCATIONS')\n\nexport function clearLocation (payload) {\n  return function (dispatch, getState) {\n    dispatch(clearingLocation(payload))\n    dispatch(formChanged())\n  }\n}\n\nexport function setLocation (payload) {\n  return function (dispatch, getState) {\n    const otpState = getState().otp\n\n    // reverse geocode point location if requested\n    if (payload.reverseGeocode) {\n      const {MAPZEN_KEY, baseUrl} = otpState.config.geocoder\n      const {location: point} = payload\n      reverse({\n        apiKey: MAPZEN_KEY,\n        point,\n        format: true,\n        url: baseUrl ? `${baseUrl}/reverse` : null\n      }).then((json) => {\n        // override location name if reverse geocode is successful\n        payload.location.name = json[0].address\n        dispatch(settingLocation({\n          type: payload.type,\n          location: Object.assign({}, payload.location, {name: json[0].address})\n        }))\n        // Trigger form change after reverse geocode so that OTP query contains\n        // reverse geocoded place name\n        dispatch(formChanged())\n      }).catch((err) => {\n        dispatch(settingLocation({\n          type: payload.type,\n          location: payload.location\n        }))\n        dispatch(formChanged())\n        console.warn(err)\n      })\n    } else {\n      // update the location in the store\n      dispatch(settingLocation(payload))\n      dispatch(formChanged())\n    }\n  }\n}\n\n/* payload is simply { type: 'from'|'to' }; location filled in automatically */\n\nexport function setLocationToCurrent (payload) {\n  return function (dispatch, getState) {\n    const currentPosition = getState().otp.location.currentPosition\n    if (currentPosition.error || !currentPosition.coords) return\n    payload.location = {\n      lat: currentPosition.coords.latitude,\n      lon: currentPosition.coords.longitude,\n      name: '(Current Location)'\n    }\n    dispatch(settingLocation(payload))\n    dispatch(formChanged())\n  }\n}\n\nexport function switchLocations () {\n  return function (dispatch, getState) {\n    const {from, to} = getState().otp.currentQuery\n    dispatch(settingLocation({\n      type: 'from',\n      location: to\n    }))\n    dispatch(settingLocation({\n      type: 'to',\n      location: from\n    }))\n    dispatch(formChanged())\n  }\n}\n\nexport const showLegDiagram = createAction('SHOW_LEG_DIAGRAM')\n\nexport const setElevationPoint = createAction('SET_ELEVATION_POINT')\n"]}