{"version":3,"sources":["form.js"],"names":["setQueryParam","parseUrlQueryString","formChanged","settingQueryParam","clearActiveSearch","payload","dispatch","getState","queryString","params","qs","parse","substring","planParams","forEach","key","startsWith","planParamsToQuery","parseLocationString","value","parts","split","coordinates","name","length","lat","lon","query","from","fromPlace","to","toPlace","departArrive","arriveBy","date","time","isNaN","parseFloat","debouncedPlanTrip","lastDebouncePlanTimeMs","oldQuery","newQuery","otpState","otp","currentQuery","format","fromChanged","toChanged","MobileScreens","SEARCH_FORM","config","autoPlan","debouncePlanTimeMs","updatePlan"],"mappings":";;;;;;;;;;;QA4BgBA,a,GAAAA,a;QAMAC,mB,GAAAA,mB;QAmEAC,W,GAAAA,W;;AArGhB;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;AASO,IAAMC,gDAAoB,gCAAa,iBAAb,CAA1B;AACA,IAAMC,gDAAoB,gCAAa,qBAAb,CAA1B;;AAEP;;;;AAIO,SAASJ,aAAT,CAAwBK,OAAxB,EAAiC;AACtC,SAAO,UAAUC,QAAV,EAAoBC,QAApB,EAA8B;AACnCD,aAASH,kBAAkBE,OAAlB,CAAT;AACD,GAFD;AAGD;;AAEM,SAASJ,mBAAT,CAA8BO,WAA9B,EAA2C;AAChD,SAAO,UAAUF,QAAV,EAAoBC,QAApB,EAA8B;AACnC;AACA,QAAME,SAASC,aAAGC,KAAH,CAASH,YAAYI,SAAZ,CAAsB,CAAtB,CAAT,CAAf;AACA;AACA,QAAMC,aAAa,EAAnB;AACA,wBAAYJ,MAAZ,EAAoBK,OAApB,CAA4B,eAAO;AACjC,UAAI,CAACC,IAAIC,UAAJ,CAAe,KAAf,CAAL,EAA4BH,WAAWE,GAAX,IAAkBN,OAAOM,GAAP,CAAlB;AAC7B,KAFD;AAGA;AACAT,aAASN,cAAciB,kBAAkBJ,UAAlB,CAAd,CAAT;AACD,GAVD;AAWD;;AAED;;;;AAIA,SAASK,mBAAT,CAA8BC,KAA9B,EAAqC;AACnC,MAAMC,QAAQD,MAAME,KAAN,CAAY,IAAZ,CAAd;AACA,MAAMC,cAAcF,MAAM,CAAN,IAChB,yBAAeA,MAAM,CAAN,CAAf,CADgB,GAEhB,yBAAeA,MAAM,CAAN,CAAf,CAFJ;AAGA,MAAMG,OAAOH,MAAM,CAAN,IACTA,MAAM,CAAN,CADS,GAET,yBAAeE,WAAf,CAFJ;AAGA,SAAOA,YAAYE,MAAZ,KAAuB,CAAvB,GAA2B;AAChCD,UAAMA,QAAQ,IADkB;AAEhCE,SAAKH,YAAY,CAAZ,KAAkB,IAFS;AAGhCI,SAAKJ,YAAY,CAAZ,KAAkB;AAHS,GAA3B,GAIH,IAJJ;AAKD;;AAED,SAASL,iBAAT,CAA4BR,MAA5B,EAAoC;AAClC,MAAMkB,QAAQ,EAAd;AACA,OAAK,IAAIZ,GAAT,IAAgBN,MAAhB,EAAwB;AACtB,YAAQM,GAAR;AACE,WAAK,WAAL;AACEY,cAAMC,IAAN,GAAaV,oBAAoBT,OAAOoB,SAA3B,CAAb;AACA;AACF,WAAK,SAAL;AACEF,cAAMG,EAAN,GAAWZ,oBAAoBT,OAAOsB,OAA3B,CAAX;AACA;AACF,WAAK,UAAL;AACEJ,cAAMK,YAAN,GAAqBvB,OAAOwB,QAAP,KAAoB,MAApB,GACjB,QADiB,GAEjBxB,OAAOwB,QAAP,KAAoB,OAApB,GACE,QADF,GAEE,KAJN;AAKA;AACF,WAAK,MAAL;AACEN,cAAMO,IAAN,GAAazB,OAAOyB,IAAP,IAAe,2BAA5B;AACA;AACF,WAAK,MAAL;AACEP,cAAMQ,IAAN,GAAa1B,OAAO0B,IAAP,IAAe,2BAA5B;AACA;AACF;AACE,YAAI,CAACC,MAAM3B,OAAOM,GAAP,CAAN,CAAL,EAAyBY,MAAMZ,GAAN,IAAasB,WAAW5B,OAAOM,GAAP,CAAX,CAAb,CAAzB,KACKY,MAAMZ,GAAN,IAAaN,OAAOM,GAAP,CAAb;AAtBT;AAwBD;AACD,SAAOY,KAAP;AACD;;AAED,IAAIW,0BAAJ,C,CAAsB;AACtB,IAAIC,+BAAJ;;AAEO,SAASrC,WAAT,CAAsBsC,QAAtB,EAAgCC,QAAhC,EAA0C;AAC/C,SAAO,UAAUnC,QAAV,EAAoBC,QAApB,EAA8B;AACnC,QAAMmC,WAAWnC,WAAWoC,GAA5B;;AAEA;AACA,QAAID,SAASE,YAAT,IAAyBF,SAASE,YAAT,CAAsBZ,YAAtB,KAAuC,KAApE,EAA2E;AACzE1B,eAASH,kBAAkB,EAAEgC,MAAM,wBAASU,MAAT,CAAgB,OAAhB,CAAR,EAAlB,CAAT;AACD;;AAED;AACA,QAAMC,cAAc,CAAC,sBAAQN,SAASZ,IAAjB,EAAuBa,SAASb,IAAhC,CAArB;AACA,QAAMmB,YAAY,CAAC,sBAAQP,SAASV,EAAjB,EAAqBW,SAASX,EAA9B,CAAnB;;AAEA;AACA,QAAIgB,eAAeC,SAAnB,EAA8B;AAC5BzC,eAAS,wBAAc,IAAd,CAAT;AACAA,eAAS,wBAAc,IAAd,CAAT;AACAA,eAAS,yBAAe,IAAf,CAAT;AACAA,eAAS,8BAAoB,IAApB,CAAT;AACD;;AAED;AACA,QAAI,wBAAewC,eAAeC,SAA9B,CAAJ,EAA8C;AAC5CzC,eAASF,mBAAT;AACAE,eAAS,0BAAgB0C,mBAAcC,WAA9B,CAAT;AACD;;AAED;AA1BmC,2BA2BIP,SAASQ,MA3Bb;AAAA,QA2B5BC,QA3B4B,oBA2B5BA,QA3B4B;AAAA,QA2BlBC,kBA3BkB,oBA2BlBA,kBA3BkB;;AA4BnC,QAAMC,aACJF,YACC,CAAC,mBAAD,KAAgBL,eAAeC,SAA/B,CADD,IAC+C;AAC/C,2BAAcD,WAAd,IAA6BC,SAH/B;AAIA,QAAIM,cAAc,yBAAaX,QAAb,CAAlB,EAA0C;AAAE;AAC1C;AACA,UAAI,CAACJ,iBAAD,IAAsBC,2BAA2Ba,kBAArD,EAAyE;AACvEd,4BAAoB,sBAAS;AAAA,iBAAMhC,SAAS,wBAAT,CAAN;AAAA,SAAT,EAAyC8C,kBAAzC,CAApB;AACAb,iCAAyBa,kBAAzB;AACD;AACDd;AACD;AACF,GAxCD;AAyCD","file":"form.js","sourcesContent":["import debounce from 'lodash.debounce'\nimport qs from 'qs'\nimport moment from 'moment'\nimport { createAction } from 'redux-actions'\nimport isEqual from 'lodash.isequal'\n\nimport { routingQuery } from './api'\nimport { coordsToString, stringToCoords } from '../util/map'\nimport { queryIsValid } from '../util/state'\nimport { getCurrentTime, getCurrentDate } from '../util/time'\nimport { isMobile } from '../util/ui'\n\nimport {\n  MobileScreens,\n  setViewedStop,\n  setViewedTrip,\n  setViewedRoute,\n  setMainPanelContent,\n  setMobileScreen\n} from '../actions/ui'\n\nexport const settingQueryParam = createAction('SET_QUERY_PARAM')\nexport const clearActiveSearch = createAction('CLEAR_ACTIVE_SEARCH')\n\n/**\n * Action to update any specified query parameter. Replaces previous series of\n * parameter-specific actions.\n */\nexport function setQueryParam (payload) {\n  return function (dispatch, getState) {\n    dispatch(settingQueryParam(payload))\n  }\n}\n\nexport function parseUrlQueryString (queryString) {\n  return function (dispatch, getState) {\n    // Trim the leading question mark\n    const params = qs.parse(queryString.substring(1))\n    // Filter out the OTP (i.e. non-UI) params and set the initial query\n    const planParams = {}\n    Object.keys(params).forEach(key => {\n      if (!key.startsWith('ui_')) planParams[key] = params[key]\n    })\n    // Convert strings to numbers/objects and dispatch\n    dispatch(setQueryParam(planParamsToQuery(planParams)))\n  }\n}\n\n/**\n * OTP allows passing a location in the form '123 Main St::lat,lon', so we check\n * for the double colon and parse the coordinates accordingly.\n */\nfunction parseLocationString (value) {\n  const parts = value.split('::')\n  const coordinates = parts[1]\n    ? stringToCoords(parts[1])\n    : stringToCoords(parts[0])\n  const name = parts[1]\n    ? parts[0]\n    : coordsToString(coordinates)\n  return coordinates.length === 2 ? {\n    name: name || null,\n    lat: coordinates[0] || null,\n    lon: coordinates[1] || null\n  } : null\n}\n\nfunction planParamsToQuery (params) {\n  const query = {}\n  for (var key in params) {\n    switch (key) {\n      case 'fromPlace':\n        query.from = parseLocationString(params.fromPlace)\n        break\n      case 'toPlace':\n        query.to = parseLocationString(params.toPlace)\n        break\n      case 'arriveBy':\n        query.departArrive = params.arriveBy === 'true'\n          ? 'ARRIVE'\n          : params.arriveBy === 'false'\n            ? 'DEPART'\n            : 'NOW'\n        break\n      case 'date':\n        query.date = params.date || getCurrentDate()\n        break\n      case 'time':\n        query.time = params.time || getCurrentTime()\n        break\n      default:\n        if (!isNaN(params[key])) query[key] = parseFloat(params[key])\n        else query[key] = params[key]\n    }\n  }\n  return query\n}\n\nlet debouncedPlanTrip // store as variable here, so it can be reused.\nlet lastDebouncePlanTimeMs\n\nexport function formChanged (oldQuery, newQuery) {\n  return function (dispatch, getState) {\n    const otpState = getState().otp\n\n    // If departArrive is set to 'NOW', update the query time to current\n    if (otpState.currentQuery && otpState.currentQuery.departArrive === 'NOW') {\n      dispatch(settingQueryParam({ time: moment().format('HH:mm') }))\n    }\n\n    // Determine if either from/to location has changed\n    const fromChanged = !isEqual(oldQuery.from, newQuery.from)\n    const toChanged = !isEqual(oldQuery.to, newQuery.to)\n\n    // Clear the main panel if location changed\n    if (fromChanged || toChanged) {\n      dispatch(setViewedStop(null))\n      dispatch(setViewedTrip(null))\n      dispatch(setViewedRoute(null))\n      dispatch(setMainPanelContent(null))\n    }\n\n    // Clear the current search and return to search screen on mobile when either location changes\n    if (isMobile() && (fromChanged || toChanged)) {\n      dispatch(clearActiveSearch())\n      dispatch(setMobileScreen(MobileScreens.SEARCH_FORM))\n    }\n\n    // Check whether a trip should be auto-replanned\n    const {autoPlan, debouncePlanTimeMs} = otpState.config\n    const updatePlan =\n      autoPlan ||\n      (!isMobile() && (fromChanged || toChanged)) || // TODO: make autoplan configurable at the parameter level?\n      isMobile() && fromChanged && toChanged\n    if (updatePlan && queryIsValid(otpState)) { // trip plan should be made\n      // check if debouncing function needs to be (re)created\n      if (!debouncedPlanTrip || lastDebouncePlanTimeMs !== debouncePlanTimeMs) {\n        debouncedPlanTrip = debounce(() => dispatch(routingQuery()), debouncePlanTimeMs)\n        lastDebouncePlanTimeMs = debouncePlanTimeMs\n      }\n      debouncedPlanTrip()\n    }\n  }\n}\n"]}