{"version":3,"sources":["api.js"],"names":["routingQuery","parkAndRideQuery","bikeRentalQuery","carRentalQuery","findStop","findTrip","findStopsForTrip","findStopTimesForTrip","findGeometryForTrip","findStopTimesForStop","findRoutes","findRoute","findPatternsForRoute","findGeometryForPattern","getTransportationNetworkCompanyEtaEstimate","getTransportationNetworkCompanyRideEstimate","findNearbyStops","findRoutesAtStop","findStopsWithinBBox","fetch","require","nonRealtimeRoutingResponse","routingRequest","routingResponse","routingError","lastSearchId","dispatch","getState","otpState","otp","routingType","currentQuery","searchId","constructRoutingQuery","then","getJsonAndCheckResponse","response","json","catch","error","console","res","status","Error","ignoreRealtimeUpdates","config","isItinerary","rt","routingTypes","find","key","api","planEndpoint","host","port","path","params","queryParams","filter","qp","indexOf","name","applicable","forEach","rewriteFunction","itineraryRewrite","profileRewrite","dateValid","date","isValid","timeValid","time","mode","includes","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime","qs","stringify","parkAndRideError","parkAndRideResponse","endpoint","length","map","join","createQueryAction","bikeRentalError","bikeRentalResponse","carRentalResponse","carRentalError","companies","findStopResponse","findStopError","stopId","serviceId","postprocess","payload","findTripResponse","findTripError","tripId","findStopsForTripResponse","findStopsForTripError","rewritePayload","stops","findStopTimesForTripResponse","findStopTimesForTripError","stopTimes","findGeometryForTripResponse","findGeometryForTripError","geometry","findStopTimesForStopResponse","findStopTimesForStopError","findRoutesResponse","findRoutesError","routes","rte","id","findRouteResponse","findRouteError","routeId","findPatternsForRouteResponse","findPatternsForRouteError","patterns","ptn","patternId","findGeometryForPatternResponse","findGeometryForPatternError","transportationNetworkCompanyEtaResponse","transportationNetworkCompanyEtaError","from","estimates","transportationNetworkCompanyRideResponse","transportationNetworkCompanyRideError","company","rideType","to","rideEstimate","receivedNearbyStopsResponse","receivedNearbyStopsError","radius","stop","distance","latitude","lat","longitude","lon","sort","a","b","max","slice","receivedRoutesAtStopResponse","receivedRoutesAtStopError","receivedStopsWithinBBoxResponse","receivedStopsWithinBBoxError","clearStops","responseAction","errorAction","options","url","alternateTransitIndex","services","log","apiRoot"],"mappings":"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","file":"api.js","sourcesContent":["/* globals fetch */\n\nimport { createAction } from 'redux-actions'\nimport qs from 'qs'\nimport moment from 'moment'\nimport haversine from 'haversine'\nif (typeof (fetch) === 'undefined') require('isomorphic-fetch')\n\nimport { queryIsValid } from '../util/state'\nimport queryParams from '../util/query-params'\nimport { updateOtpUrlParams } from '../util/query'\nimport { hasCar } from '../util/itinerary'\n\n// Generic API actions\n\nexport const nonRealtimeRoutingResponse = createAction('NON_REALTIME_ROUTING_RESPONSE')\nexport const routingRequest = createAction('ROUTING_REQUEST')\nexport const routingResponse = createAction('ROUTING_RESPONSE')\nexport const routingError = createAction('ROUTING_ERROR')\n\nlet lastSearchId = 0\n\nexport function routingQuery () {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    const routingType = otpState.currentQuery.routingType\n    const searchId = ++lastSearchId\n\n    if (!queryIsValid(otpState)) return\n    dispatch(routingRequest({ routingType, searchId }))\n\n    // fetch a realtime route\n    fetch(constructRoutingQuery(otpState))\n      .then(getJsonAndCheckResponse)\n      .then(json => {\n        dispatch(routingResponse({ response: json, searchId }))\n      })\n      .catch(error => {\n        dispatch(routingError({ error, searchId }))\n      })\n\n    // also fetch a non-realtime route\n    fetch(constructRoutingQuery(otpState, true))\n      .then(getJsonAndCheckResponse)\n      .then(json => {\n        dispatch(nonRealtimeRoutingResponse({ response: json, searchId }))\n      })\n      .catch(error => {\n        console.error(error)\n        // do nothing\n      })\n  }\n}\n\nfunction getJsonAndCheckResponse (res) {\n  if (res.status >= 400) {\n    const error = new Error('Received error from server')\n    error.response = res\n    throw error\n  }\n  return res.json()\n}\n\nfunction constructRoutingQuery (otpState, ignoreRealtimeUpdates) {\n  const { config, currentQuery } = otpState\n  const routingType = currentQuery.routingType\n  const isItinerary = routingType === 'ITINERARY'\n\n  // Check for routingType-specific API config; if none, use default API\n  const rt = config.routingTypes && config.routingTypes.find(rt => rt.key === routingType)\n  const api = rt.api || config.api\n  const planEndpoint = `${api.host}${api.port\n    ? ':' + api.port\n    : ''}${api.path}/plan`\n\n  let params = {}\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in currentQuery &&\n        (typeof qp.applicable !== 'function' || qp.applicable(currentQuery, config))\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(currentQuery[qp.name])\n          : { [qp.name]: currentQuery[qp.name] }\n      )\n    })\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === 'boolean') {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, 'YYYY-MM-DD').isValid()\n    const timeValid = moment(params.time, 'H:mm').isValid()\n\n    if (!dateValid || !timeValid) {\n      delete params.time\n      delete params.date\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes('CAR_HAIL') || params.mode.includes('CAR_RENT'))\n    ) {\n      params.minTransitDistance = '50%'\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes('CAR_RENT')) {\n      params.onlyTransitTrips = true\n    }\n\n  // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(params.startTime, 'H:mm').isValid()\n    const endTimeValid = moment(params.endTime, 'H:mm').isValid()\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid\n      delete params.endTimeValid\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // FIXME: This is only performed when ignoring realtimeupdates currently, just\n  // to ensure it is not repeated twice.\n  if (ignoreRealtimeUpdates) updateOtpUrlParams(params)\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += ',WALK'\n  }\n\n  return `${planEndpoint}?${qs.stringify(params)}`\n}\n\n// Park and Ride location query\n\nexport const parkAndRideError = createAction('PARK_AND_RIDE_ERROR')\nexport const parkAndRideResponse = createAction('PARK_AND_RIDE_RESPONSE')\n\nexport function parkAndRideQuery (params) {\n  let endpoint = 'park_and_ride'\n  if (params && Object.keys(params).length > 0) {\n    endpoint += '?' + Object.keys(params).map(key => key + '=' + params[key]).join('&')\n  }\n  return createQueryAction(endpoint, parkAndRideResponse, parkAndRideError)\n}\n\n// bike rental station query\n\nexport const bikeRentalError = createAction('BIKE_RENTAL_ERROR')\nexport const bikeRentalResponse = createAction('BIKE_RENTAL_RESPONSE')\n\nexport function bikeRentalQuery (params) {\n  return createQueryAction('bike_rental', bikeRentalResponse, bikeRentalError)\n}\n\n// Car rental (e.g. car2go) locations lookup query\n\nexport const carRentalResponse = createAction('CAR_RENTAL_RESPONSE')\nexport const carRentalError = createAction('CAR_RENTAL_ERROR')\n\nexport function carRentalQuery () {\n  return function (dispatch, getState) {\n    const {companies} = getState().otp.currentQuery\n    return dispatch(createQueryAction(\n      `car_rental?${qs.stringify({companies})}`,\n      carRentalResponse,\n      carRentalError\n    ))\n  }\n}\n\n// Single stop lookup query\n\nexport const findStopResponse = createAction('FIND_STOP_RESPONSE')\nexport const findStopError = createAction('FIND_STOP_ERROR')\n\nexport function findStop (params) {\n  return createQueryAction(\n    `index/stops/${params.stopId}`,\n    findStopResponse,\n    findStopError,\n    {\n      serviceId: 'stops',\n      postprocess: (payload, dispatch) => {\n        dispatch(findRoutesAtStop(params.stopId))\n        dispatch(findStopTimesForStop({stopId: params.stopId}))\n      }\n    }\n  )\n}\n\n// Single trip lookup query\n\nexport const findTripResponse = createAction('FIND_TRIP_RESPONSE')\nexport const findTripError = createAction('FIND_TRIP_ERROR')\n\nexport function findTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}`,\n    findTripResponse,\n    findTripError,\n    {\n      postprocess: (payload, dispatch) => {\n        dispatch(findStopsForTrip({tripId: params.tripId}))\n        dispatch(findStopTimesForTrip({tripId: params.tripId}))\n        dispatch(findGeometryForTrip({tripId: params.tripId}))\n      }\n    }\n  )\n}\n\n// Stops for trip query\n\nexport const findStopsForTripResponse = createAction('FIND_STOPS_FOR_TRIP_RESPONSE')\nexport const findStopsForTripError = createAction('FIND_STOPS_FOR_TRIP_ERROR')\n\nexport function findStopsForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stops`,\n    findStopsForTripResponse,\n    findStopsForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stops: payload\n        }\n      }\n    }\n  )\n}\n\n// Stop times for trip query\n\nexport const findStopTimesForTripResponse = createAction('FIND_STOP_TIMES_FOR_TRIP_RESPONSE')\nexport const findStopTimesForTripError = createAction('FIND_STOP_TIMES_FOR_TRIP_ERROR')\n\nexport function findStopTimesForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stoptimes`,\n    findStopTimesForTripResponse,\n    findStopTimesForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stopTimes: payload\n        }\n      }\n    }\n  )\n}\n\n// Geometry for trip query\n\nexport const findGeometryForTripResponse = createAction('FIND_GEOMETRY_FOR_TRIP_RESPONSE')\nexport const findGeometryForTripError = createAction('FIND_GEOMETRY_FOR_TRIP_ERROR')\n\nexport function findGeometryForTrip (params) {\n  return createQueryAction(`index/trips/${params.tripId}/geometry`,\n    findGeometryForTripResponse, findGeometryForTripError,\n    (payload) => {\n      return {\n        tripId: params.tripId,\n        geometry: payload\n      }\n    }\n  )\n}\n\n// Stop times for stop query\n// TODO: make timeRange and numberOfDepartures configurable\n\nexport const findStopTimesForStopResponse = createAction('FIND_STOP_TIMES_FOR_STOP_RESPONSE')\nexport const findStopTimesForStopError = createAction('FIND_STOP_TIMES_FOR_STOP_ERROR')\n\nexport function findStopTimesForStop (params) {\n  return createQueryAction(\n    `index/stops/${params.stopId}/stoptimes?timeRange=345600&numberOfDepartures=5`,\n    findStopTimesForStopResponse,\n    findStopTimesForStopError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          stopId: params.stopId,\n          stopTimes: payload\n        }\n      }\n    }\n  )\n}\n\n// Routes lookup query\n\nexport const findRoutesResponse = createAction('FIND_ROUTES_RESPONSE')\nexport const findRoutesError = createAction('FIND_ROUTES_ERROR')\n\nexport function findRoutes (params) {\n  return createQueryAction(\n    'index/routes',\n    findRoutesResponse,\n    findRoutesError,\n    {\n      serviceId: 'routes',\n      rewritePayload: (payload) => {\n        const routes = {}\n        payload.forEach(rte => { routes[rte.id] = rte })\n        return routes\n      }\n    }\n  )\n}\n\n// Single Route lookup query\n\nexport const findRouteResponse = createAction('FIND_ROUTE_RESPONSE')\nexport const findRouteError = createAction('FIND_ROUTE_ERROR')\n\nexport function findRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}`,\n    findRouteResponse,\n    findRouteError,\n    {\n      postprocess: (payload, dispatch) => {\n        // load patterns\n        dispatch(findPatternsForRoute({ routeId: params.routeId }))\n      }\n    }\n  )\n}\n\n// Patterns for Route lookup query\n\nexport const findPatternsForRouteResponse = createAction('FIND_PATTERNS_FOR_ROUTE_RESPONSE')\nexport const findPatternsForRouteError = createAction('FIND_PATTERNS_FOR_ROUTE_ERROR')\n\nexport function findPatternsForRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}/patterns`,\n    findPatternsForRouteResponse,\n    findPatternsForRouteError,\n    {\n      rewritePayload: (payload) => {\n        // convert pattern array to ID-mapped object\n        const patterns = {}\n        payload.forEach(ptn => { patterns[ptn.id] = ptn })\n\n        return {\n          routeId: params.routeId,\n          patterns\n        }\n      },\n      postprocess: (payload, dispatch) => {\n        // load geometry for each pattern\n        payload.forEach(ptn => {\n          dispatch(findGeometryForPattern({\n            routeId: params.routeId,\n            patternId: ptn.id\n          }))\n        })\n      }\n    }\n  )\n}\n\n// Geometry for Pattern lookup query\n\nexport const findGeometryForPatternResponse = createAction('FIND_GEOMETRY_FOR_PATTERN_RESPONSE')\nexport const findGeometryForPatternError = createAction('FIND_GEOMETRY_FOR_PATTERN_ERROR')\n\nexport function findGeometryForPattern (params) {\n  return createQueryAction(\n    `index/patterns/${params.patternId}/geometry`,\n    findGeometryForPatternResponse,\n    findGeometryForPatternError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          routeId: params.routeId,\n          patternId: params.patternId,\n          geometry: payload\n        }\n      }\n    }\n  )\n}\n\n// TNC ETA estimate lookup query\n\nexport const transportationNetworkCompanyEtaResponse = createAction('TNC_ETA_RESPONSE')\nexport const transportationNetworkCompanyEtaError = createAction('TNC_ETA_ERROR')\n\nexport function getTransportationNetworkCompanyEtaEstimate (params) {\n  const {companies, from} = params\n  return createQueryAction(\n    `transportation_network_company/eta_estimate?${qs.stringify({\n      companies,\n      from\n    })}`, // endpoint\n    transportationNetworkCompanyEtaResponse, // responseAction\n    transportationNetworkCompanyEtaError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          from,\n          estimates: payload.estimates\n        }\n      }\n    }\n  )\n}\n\n// TNC ride estimate lookup query\n\nexport const transportationNetworkCompanyRideResponse = createAction('TNC_RIDE_RESPONSE')\nexport const transportationNetworkCompanyRideError = createAction('TNC_RIDE_ERROR')\n\nexport function getTransportationNetworkCompanyRideEstimate (params) {\n  const {company, from, rideType, to} = params\n  return createQueryAction(\n    `transportation_network_company/ride_estimate?${qs.stringify({\n      company,\n      from,\n      rideType,\n      to\n    })}`, // endpoint\n    transportationNetworkCompanyRideResponse, // responseAction\n    transportationNetworkCompanyRideError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          company,\n          from,\n          rideEstimate: payload.rideEstimate,\n          to\n        }\n      }\n    }\n  )\n}\n\n// Nearby Stops Query\n\nconst receivedNearbyStopsResponse = createAction('NEARBY_STOPS_RESPONSE')\nconst receivedNearbyStopsError = createAction('NEARBY_STOPS_ERROR')\n\nexport function findNearbyStops (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify({radius: 1000, ...params})}`,\n    receivedNearbyStopsResponse,\n    receivedNearbyStopsError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => {\n        if (stops) {\n          // Sort the stops by proximity\n          stops.forEach(stop => {\n            stop.distance = haversine(\n              { latitude: params.lat, longitude: params.lon },\n              { latitude: stop.lat, longitude: stop.lon }\n            )\n          })\n          stops.sort((a, b) => { return a.distance - b.distance })\n          if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        }\n        return {stops}\n      },\n      // retrieve routes for each stop\n      postprocess: (stops, dispatch, getState) => {\n        if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        stops.forEach(stop => dispatch(findRoutesAtStop(stop.id)))\n      }\n    }\n  )\n}\n\n// Routes at Stop query\n\nconst receivedRoutesAtStopResponse = createAction('ROUTES_AT_STOP_RESPONSE')\nconst receivedRoutesAtStopError = createAction('ROUTES_AT_STOP_ERROR')\n\nexport function findRoutesAtStop (stopId) {\n  return createQueryAction(\n    `index/stops/${stopId}/routes`,\n    receivedRoutesAtStopResponse,\n    receivedRoutesAtStopError,\n    {\n      serviceId: 'stops/routes',\n      rewritePayload: routes => ({stopId, routes})\n    }\n  )\n}\n\n// Stops within Bounding Box Query\n\nconst receivedStopsWithinBBoxResponse = createAction('STOPS_WITHIN_BBOX_RESPONSE')\nconst receivedStopsWithinBBoxError = createAction('STOPS_WITHIN_BBOX_ERROR')\n\nexport function findStopsWithinBBox (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify(params)}`,\n    receivedStopsWithinBBoxResponse,\n    receivedStopsWithinBBoxError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => ({stops})\n    }\n  )\n}\n\nexport const clearStops = createAction('CLEAR_STOPS_OVERLAY')\n\n\n/**\n * Generic helper for constructing API queries\n *\n * @param {String} endpoint - The API endpoint path (does not include\n *   '../otp/routers/router_id/')\n * @param {Function} responseAction - Action to dispatch on a successful API\n *   response. Accepts payload object parameter.\n * @param {Function} errorAction - Function to invoke on API error response.\n *   Accepts error object parameter.\n * @param {Options} options - Any of the following optional settings:\n *   - rewritePayload: Function to be invoked to modify payload before being\n *       passed to responseAction. Accepts and returns payload object.\n *   - postprocess: Function to be invoked after responseAction is invoked.\n *       Accepts payload, dispatch, getState parameters.\n *   - serviceId: identifier for TransitIndex service used in\n *       alternateTransitIndex configuration.\n */\n\nfunction createQueryAction (endpoint, responseAction, errorAction, options) {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    let url\n    if (options && options.serviceId && otpState.config.alternateTransitIndex &&\n      otpState.config.alternateTransitIndex.services.includes(options.serviceId)\n    ) {\n      console.log('Using alt service for ' + options.serviceId)\n      url = otpState.config.alternateTransitIndex.apiRoot + endpoint\n    } else {\n      const api = otpState.config.api\n      url = `${api.host}${api.port ? ':' + api.port : ''}${api.path}/${endpoint}`\n    }\n    let payload\n    try {\n      const response = await fetch(url)\n      if (response.status >= 400) {\n        const error = new Error('Received error from server')\n        error.response = response\n        throw error\n      }\n      payload = await response.json()\n    } catch (err) {\n      return dispatch(errorAction(err))\n    }\n\n    if (options && typeof options.rewritePayload === 'function') {\n      dispatch(responseAction(options.rewritePayload(payload)))\n    } else {\n      dispatch(responseAction(payload))\n    }\n\n    if (options && typeof options.postprocess === 'function') {\n      options.postprocess(payload, dispatch, getState)\n    }\n  }\n}\n"]}