{"version":3,"sources":["api.js"],"names":["routingQuery","parkAndRideQuery","bikeRentalQuery","carRentalQuery","vehicleRentalQuery","findStop","findTrip","findStopsForTrip","findStopTimesForTrip","findGeometryForTrip","findStopTimesForStop","findRoutes","findRoute","getTransportationNetworkCompanyEtaEstimate","getTransportationNetworkCompanyRideEstimate","findNearbyStops","findRoutesAtStop","findStopsWithinBBox","fetch","require","nonRealtimeRoutingResponse","routingRequest","routingResponse","routingError","toggleTracking","rememberSearch","forgetSearch","lastSearchId","randId","Math","random","toString","replace","substr","formatRecentPlace","place","type","icon","id","timestamp","Date","getTime","forgettable","formatRecentSearch","url","otpState","query","currentQuery","dispatch","getState","otp","routingType","searchId","constructRoutingQuery","console","log","then","getJsonAndCheckResponse","response","json","user","trackRecent","from","to","location","catch","error","res","status","Error","ignoreRealtimeUpdates","config","isItinerary","rt","routingTypes","find","key","api","planEndpoint","host","port","path","params","queryParams","filter","qp","indexOf","name","applicable","forEach","rewriteFunction","itineraryRewrite","profileRewrite","dateValid","date","isValid","timeValid","time","mode","includes","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime","qs","stringify","parkAndRideError","parkAndRideResponse","endpoint","length","map","join","createQueryAction","bikeRentalError","bikeRentalResponse","carRentalResponse","carRentalError","vehicleRentalResponse","vehicleRentalError","findStopResponse","findStopError","stopId","serviceId","postprocess","payload","findTripResponse","findTripError","tripId","findStopsForTripResponse","findStopsForTripError","rewritePayload","stops","findStopTimesForTripResponse","findStopTimesForTripError","stopTimes","findGeometryForTripResponse","findGeometryForTripError","geometry","findStopTimesForStopResponse","findStopTimesForStopError","findRoutesResponse","findRoutesError","createGraphQLQueryAction","routes","data","rte","findPatternsForRouteResponse","findPatternsForRouteError","routeId","patterns","ptn","patternId","transportationNetworkCompanyEtaResponse","transportationNetworkCompanyEtaError","companies","estimates","transportationNetworkCompanyRideResponse","transportationNetworkCompanyRideError","company","rideType","rideEstimate","receivedNearbyStopsResponse","receivedNearbyStopsError","radius","stop","distance","latitude","lat","longitude","lon","sort","a","b","max","slice","receivedRoutesAtStopResponse","receivedRoutesAtStopError","receivedStopsWithinBBoxResponse","receivedStopsWithinBBoxError","clearStops","responseAction","errorAction","options","alternateTransitIndex","services","apiRoot","fetchOptions","variables","method","body","headers"],"mappings":"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","file":"api.js","sourcesContent":["/* globals fetch */\n\nimport { createAction } from 'redux-actions'\nimport qs from 'qs'\nimport moment from 'moment'\nimport haversine from 'haversine'\n\nimport { rememberPlace } from './map'\nimport { queryIsValid } from '../util/state'\nimport queryParams from '../util/query-params'\nimport { getTripOptionsFromQuery, updateOtpUrlParams } from '../util/query'\nimport { hasCar } from '../util/itinerary'\nif (typeof (fetch) === 'undefined') require('isomorphic-fetch')\n\n// Generic API actions\n\nexport const nonRealtimeRoutingResponse = createAction('NON_REALTIME_ROUTING_RESPONSE')\nexport const routingRequest = createAction('ROUTING_REQUEST')\nexport const routingResponse = createAction('ROUTING_RESPONSE')\nexport const routingError = createAction('ROUTING_ERROR')\nexport const toggleTracking = createAction('TOGGLE_TRACKING')\nexport const rememberSearch = createAction('REMEMBER_SEARCH')\nexport const forgetSearch = createAction('FORGET_SEARCH')\n\nlet lastSearchId = 0\n\nfunction randId () {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(2, 10)\n}\n\nfunction formatRecentPlace (place) {\n  return {\n    ...place,\n    type: 'recent',\n    icon: 'clock-o',\n    id: `recent-${randId()}`,\n    timestamp: new Date().getTime(),\n    forgettable: true\n  }\n}\n\nfunction formatRecentSearch (url, otpState) {\n  return {\n    query: getTripOptionsFromQuery(otpState.currentQuery, true),\n    url,\n    id: randId(),\n    timestamp: new Date().getTime()\n  }\n}\n\nexport function routingQuery () {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    const routingType = otpState.currentQuery.routingType\n    const searchId = ++lastSearchId\n\n    if (!queryIsValid(otpState)) return\n    dispatch(routingRequest({ routingType, searchId }))\n\n    // fetch a realtime route\n    const query = constructRoutingQuery(otpState)\n    console.log(query)\n    fetch(query)\n      .then(getJsonAndCheckResponse)\n      .then(json => {\n        dispatch(routingResponse({ response: json, searchId }))\n        // If tracking is enabled, store locations and search after successful\n        // search is completed.\n        // TODO recent searches\n        if (otpState.user.trackRecent) {\n          const from = formatRecentPlace(otpState.currentQuery.from)\n          const to = formatRecentPlace(otpState.currentQuery.to)\n          dispatch(rememberPlace({ type: 'recent', location: from }))\n          dispatch(rememberPlace({ type: 'recent', location: to }))\n          dispatch(rememberSearch(formatRecentSearch(query, otpState)))\n        }\n      })\n      .catch(error => {\n        dispatch(routingError({ error, searchId }))\n      })\n\n    // also fetch a non-realtime route\n    fetch(constructRoutingQuery(otpState, true))\n      .then(getJsonAndCheckResponse)\n      .then(json => {\n        dispatch(nonRealtimeRoutingResponse({ response: json, searchId }))\n      })\n      .catch(error => {\n        console.error(error)\n        // do nothing\n      })\n  }\n}\n\nfunction getJsonAndCheckResponse (res) {\n  if (res.status >= 400) {\n    const error = new Error('Received error from server')\n    error.response = res\n    throw error\n  }\n  return res.json()\n}\n\nfunction constructRoutingQuery (otpState, ignoreRealtimeUpdates) {\n  const { config, currentQuery } = otpState\n  const routingType = currentQuery.routingType\n  const isItinerary = routingType === 'ITINERARY'\n\n  // Check for routingType-specific API config; if none, use default API\n  const rt = config.routingTypes && config.routingTypes.find(rt => rt.key === routingType)\n  const api = (rt && rt.api) || config.api\n  const planEndpoint = `${api.host}${api.port\n    ? ':' + api.port\n    : ''}${api.path}/plan`\n\n  let params = {}\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in currentQuery &&\n        (typeof qp.applicable !== 'function' || qp.applicable(currentQuery, config))\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(currentQuery[qp.name])\n          : { [qp.name]: currentQuery[qp.name] }\n      )\n    })\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === 'boolean') {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, 'YYYY-MM-DD').isValid()\n    const timeValid = moment(params.time, 'H:mm').isValid()\n\n    if (!dateValid || !timeValid) {\n      delete params.time\n      delete params.date\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes('CAR_HAIL') || params.mode.includes('CAR_RENT'))\n    ) {\n      params.minTransitDistance = '50%'\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes('CAR_RENT')) {\n      params.onlyTransitTrips = true\n    }\n\n  // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(params.startTime, 'H:mm').isValid()\n    const endTimeValid = moment(params.endTime, 'H:mm').isValid()\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid\n      delete params.endTimeValid\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // FIXME: This is only performed when ignoring realtimeupdates currently, just\n  // to ensure it is not repeated twice.\n  if (ignoreRealtimeUpdates) updateOtpUrlParams(params)\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += ',WALK'\n  }\n\n  return `${planEndpoint}?${qs.stringify(params)}`\n}\n\n// Park and Ride location query\n\nexport const parkAndRideError = createAction('PARK_AND_RIDE_ERROR')\nexport const parkAndRideResponse = createAction('PARK_AND_RIDE_RESPONSE')\n\nexport function parkAndRideQuery (params) {\n  let endpoint = 'park_and_ride'\n  if (params && Object.keys(params).length > 0) {\n    endpoint += '?' + Object.keys(params).map(key => key + '=' + params[key]).join('&')\n  }\n  return createQueryAction(endpoint, parkAndRideResponse, parkAndRideError)\n}\n\n// bike rental station query\n\nexport const bikeRentalError = createAction('BIKE_RENTAL_ERROR')\nexport const bikeRentalResponse = createAction('BIKE_RENTAL_RESPONSE')\n\nexport function bikeRentalQuery (params) {\n  return createQueryAction('bike_rental', bikeRentalResponse, bikeRentalError)\n}\n\n// Car rental (e.g. car2go) locations lookup query\n\nexport const carRentalResponse = createAction('CAR_RENTAL_RESPONSE')\nexport const carRentalError = createAction('CAR_RENTAL_ERROR')\n\nexport function carRentalQuery (params) {\n  return createQueryAction('car_rental', carRentalResponse, carRentalError)\n}\n\n// Vehicle rental (e.g. Lime eScooter) locations lookup query\n\nexport const vehicleRentalResponse = createAction('VEHICLE_RENTAL_RESPONSE')\nexport const vehicleRentalError = createAction('VEHICLE_RENTAL_ERROR')\n\nexport function vehicleRentalQuery (params) {\n  return createQueryAction('vehicle_rental', vehicleRentalResponse, vehicleRentalError)\n}\n\n// Single stop lookup query\n\nexport const findStopResponse = createAction('FIND_STOP_RESPONSE')\nexport const findStopError = createAction('FIND_STOP_ERROR')\n\nexport function findStop (params) {\n  return createQueryAction(\n    `index/stops/${params.stopId}`,\n    findStopResponse,\n    findStopError,\n    {\n      serviceId: 'stops',\n      postprocess: (payload, dispatch) => {\n        dispatch(findRoutesAtStop(params.stopId))\n        dispatch(findStopTimesForStop({stopId: params.stopId}))\n      }\n    }\n  )\n}\n\n// Single trip lookup query\n\nexport const findTripResponse = createAction('FIND_TRIP_RESPONSE')\nexport const findTripError = createAction('FIND_TRIP_ERROR')\n\nexport function findTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}`,\n    findTripResponse,\n    findTripError,\n    {\n      postprocess: (payload, dispatch) => {\n        dispatch(findStopsForTrip({tripId: params.tripId}))\n        dispatch(findStopTimesForTrip({tripId: params.tripId}))\n        dispatch(findGeometryForTrip({tripId: params.tripId}))\n      }\n    }\n  )\n}\n\n// Stops for trip query\n\nexport const findStopsForTripResponse = createAction('FIND_STOPS_FOR_TRIP_RESPONSE')\nexport const findStopsForTripError = createAction('FIND_STOPS_FOR_TRIP_ERROR')\n\nexport function findStopsForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stops`,\n    findStopsForTripResponse,\n    findStopsForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stops: payload\n        }\n      }\n    }\n  )\n}\n\n// Stop times for trip query\n\nexport const findStopTimesForTripResponse = createAction('FIND_STOP_TIMES_FOR_TRIP_RESPONSE')\nexport const findStopTimesForTripError = createAction('FIND_STOP_TIMES_FOR_TRIP_ERROR')\n\nexport function findStopTimesForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stoptimes`,\n    findStopTimesForTripResponse,\n    findStopTimesForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stopTimes: payload\n        }\n      }\n    }\n  )\n}\n\n// Geometry for trip query\n\nexport const findGeometryForTripResponse = createAction('FIND_GEOMETRY_FOR_TRIP_RESPONSE')\nexport const findGeometryForTripError = createAction('FIND_GEOMETRY_FOR_TRIP_ERROR')\n\nexport function findGeometryForTrip (params) {\n  return createQueryAction(`index/trips/${params.tripId}/geometry`,\n    findGeometryForTripResponse, findGeometryForTripError,\n    (payload) => {\n      return {\n        tripId: params.tripId,\n        geometry: payload\n      }\n    }\n  )\n}\n\n// Stop times for stop query\n// TODO: make timeRange and numberOfDepartures configurable\n\nexport const findStopTimesForStopResponse = createAction('FIND_STOP_TIMES_FOR_STOP_RESPONSE')\nexport const findStopTimesForStopError = createAction('FIND_STOP_TIMES_FOR_STOP_ERROR')\n\nexport function findStopTimesForStop (params) {\n  return createQueryAction(\n    `index/stops/${params.stopId}/stoptimes?timeRange=345600&numberOfDepartures=5`,\n    findStopTimesForStopResponse,\n    findStopTimesForStopError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          stopId: params.stopId,\n          stopTimes: payload\n        }\n      }\n    }\n  )\n}\n\n// Routes lookup query\n\nexport const findRoutesResponse = createAction('FIND_ROUTES_RESPONSE')\nexport const findRoutesError = createAction('FIND_ROUTES_ERROR')\n\nexport function findRoutes (params) {\n  const query = `\n{\n  routes {\n    id: gtfsId\n    color\n    longName\n    shortName\n    mode\n    type\n    desc\n    bikesAllowed\n    sortOrder\n    textColor\n    url\n    agency {\n      id: gtfsId\n      name\n      url\n    }\n  }\n}\n  `\n  return createGraphQLQueryAction(\n    query,\n    {},\n    findRoutesResponse,\n    findRoutesError,\n    {\n      serviceId: 'routes',\n      rewritePayload: (payload) => {\n        const routes = {}\n        payload.data.routes.forEach(rte => { routes[rte.id] = rte })\n        return routes\n      }\n    }\n  )\n}\n\n// Patterns for Route lookup query\n// TODO: replace with GraphQL query for route => patterns => geometry\nexport const findPatternsForRouteResponse = createAction('FIND_PATTERNS_FOR_ROUTE_RESPONSE')\nexport const findPatternsForRouteError = createAction('FIND_PATTERNS_FOR_ROUTE_ERROR')\n\nexport function findRoute (params) {\n  const query = `\n  query routeQuery($routeId: [String]) {\n    routes (ids: $routeId) {\n      id: gtfsId\n      patterns {\n        id: semanticHash\n        directionId\n        headsign\n        name\n        semanticHash\n        geometry {\n          lat\n          lon\n        }\n      }\n    }\n  }\n  `\n  return createGraphQLQueryAction(\n    query,\n    {routeId: params.routeId},\n    findPatternsForRouteResponse,\n    findPatternsForRouteError,\n    {\n      rewritePayload: (payload) => {\n        // convert pattern array to ID-mapped object\n        const patterns = {}\n        payload.data.routes[0].patterns.forEach(ptn => {\n          patterns[ptn.id] = {\n            routeId: params.routeId,\n            patternId: ptn.id,\n            geometry: ptn.geometry\n          }\n        })\n\n        return {\n          routeId: params.routeId,\n          patterns\n        }\n      }\n    }\n  )\n}\n\n// TNC ETA estimate lookup query\n\nexport const transportationNetworkCompanyEtaResponse = createAction('TNC_ETA_RESPONSE')\nexport const transportationNetworkCompanyEtaError = createAction('TNC_ETA_ERROR')\n\nexport function getTransportationNetworkCompanyEtaEstimate (params) {\n  const {companies, from} = params\n  return createQueryAction(\n    `transportation_network_company/eta_estimate?${qs.stringify({\n      companies,\n      from\n    })}`, // endpoint\n    transportationNetworkCompanyEtaResponse, // responseAction\n    transportationNetworkCompanyEtaError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          from,\n          estimates: payload.estimates\n        }\n      }\n    }\n  )\n}\n\n// TNC ride estimate lookup query\n\nexport const transportationNetworkCompanyRideResponse = createAction('TNC_RIDE_RESPONSE')\nexport const transportationNetworkCompanyRideError = createAction('TNC_RIDE_ERROR')\n\nexport function getTransportationNetworkCompanyRideEstimate (params) {\n  const {company, from, rideType, to} = params\n  return createQueryAction(\n    `transportation_network_company/ride_estimate?${qs.stringify({\n      company,\n      from,\n      rideType,\n      to\n    })}`, // endpoint\n    transportationNetworkCompanyRideResponse, // responseAction\n    transportationNetworkCompanyRideError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          company,\n          from,\n          rideEstimate: payload.rideEstimate,\n          to\n        }\n      }\n    }\n  )\n}\n\n// Nearby Stops Query\n\nconst receivedNearbyStopsResponse = createAction('NEARBY_STOPS_RESPONSE')\nconst receivedNearbyStopsError = createAction('NEARBY_STOPS_ERROR')\n\nexport function findNearbyStops (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify({radius: 1000, ...params})}`,\n    receivedNearbyStopsResponse,\n    receivedNearbyStopsError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => {\n        if (stops) {\n          // Sort the stops by proximity\n          stops.forEach(stop => {\n            stop.distance = haversine(\n              { latitude: params.lat, longitude: params.lon },\n              { latitude: stop.lat, longitude: stop.lon }\n            )\n          })\n          stops.sort((a, b) => { return a.distance - b.distance })\n          if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        }\n        return {stops}\n      },\n      // retrieve routes for each stop\n      postprocess: (stops, dispatch, getState) => {\n        if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        stops.forEach(stop => dispatch(findRoutesAtStop(stop.id)))\n      }\n    }\n  )\n}\n\n// Routes at Stop query\n\nconst receivedRoutesAtStopResponse = createAction('ROUTES_AT_STOP_RESPONSE')\nconst receivedRoutesAtStopError = createAction('ROUTES_AT_STOP_ERROR')\n\nexport function findRoutesAtStop (stopId) {\n  return createQueryAction(\n    `index/stops/${stopId}/routes`,\n    receivedRoutesAtStopResponse,\n    receivedRoutesAtStopError,\n    {\n      serviceId: 'stops/routes',\n      rewritePayload: routes => ({stopId, routes})\n    }\n  )\n}\n\n// Stops within Bounding Box Query\n\nconst receivedStopsWithinBBoxResponse = createAction('STOPS_WITHIN_BBOX_RESPONSE')\nconst receivedStopsWithinBBoxError = createAction('STOPS_WITHIN_BBOX_ERROR')\n\nexport function findStopsWithinBBox (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify(params)}`,\n    receivedStopsWithinBBoxResponse,\n    receivedStopsWithinBBoxError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => ({stops})\n    }\n  )\n}\n\nexport const clearStops = createAction('CLEAR_STOPS_OVERLAY')\n\n/**\n * Generic helper for constructing API queries\n *\n * @param {string} endpoint - The API endpoint path (does not include\n *   '../otp/routers/router_id/')\n * @param {Function} responseAction - Action to dispatch on a successful API\n *   response. Accepts payload object parameter.\n * @param {Function} errorAction - Function to invoke on API error response.\n *   Accepts error object parameter.\n * @param {Options} options - Any of the following optional settings:\n *   - rewritePayload: Function to be invoked to modify payload before being\n *       passed to responseAction. Accepts and returns payload object.\n *   - postprocess: Function to be invoked after responseAction is invoked.\n *       Accepts payload, dispatch, getState parameters.\n *   - serviceId: identifier for TransitIndex service used in\n *       alternateTransitIndex configuration.\n *   - fetchOptions: fetch options (e.g., method, body, headers).\n */\n\nfunction createQueryAction (endpoint, responseAction, errorAction, options) {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    let url\n    if (options && options.serviceId && otpState.config.alternateTransitIndex &&\n      otpState.config.alternateTransitIndex.services.includes(options.serviceId)\n    ) {\n      console.log('Using alt service for ' + options.serviceId)\n      url = otpState.config.alternateTransitIndex.apiRoot + endpoint\n    } else {\n      const api = otpState.config.api\n      url = `${api.host}${api.port ? ':' + api.port : ''}${api.path}/${endpoint}`\n    }\n    let payload\n    try {\n      const response = await fetch(url, options.fetchOptions)\n      if (response.status >= 400) {\n        const error = new Error('Received error from server')\n        error.response = response\n        throw error\n      }\n      payload = await response.json()\n    } catch (err) {\n      return dispatch(errorAction(err))\n    }\n\n    if (options && typeof options.rewritePayload === 'function') {\n      dispatch(responseAction(options.rewritePayload(payload)))\n    } else {\n      dispatch(responseAction(payload))\n    }\n\n    if (options && typeof options.postprocess === 'function') {\n      options.postprocess(payload, dispatch, getState)\n    }\n  }\n}\n\nfunction createGraphQLQueryAction (query, variables, responseAction, errorAction, options) {\n  const endpoint = `index/graphql`\n  const fetchOptions = {\n    method: 'POST',\n    body: JSON.stringify({ query, variables }),\n    headers: { 'Content-Type': 'application/json' }\n  }\n  return createQueryAction(endpoint, responseAction, errorAction, {...options, fetchOptions})\n}\n"]}